// ====================================================================
// PENGU GAME SERIAL KEY VALIDATOR - ORGANIZED CODE
// ====================================================================

// MAIN FUNCTION - Entry point of the program
undefined8 main(void)
{
    int32_t iVar1;
    
    puts("Welcome to Pengu Game!");
    printf("Please enter a valid serial key to continue: ");
    __isoc99_scanf(data.0000420e, data.01f6b400);
    iVar1 = validate_serial_key();
    if (iVar1 == 0) {
        puts("Invalid serial key!");
    } else {
        puts("If the serial key is legit, you will get your own copy !!");
        extract_game_file();
    }
    return 0;
}

// ====================================================================
// SERIAL KEY VALIDATION FUNCTIONS
// ====================================================================

// SERIAL KEY VALIDATION - Main validation function that calls all checks
undefined8 validate_serial_key(void)
{
    int32_t iVar1;
    int64_t iVar2;
    undefined8 uVar3;
    int64_t var_ch;
    
    iVar2 = strlen(data.01f6b400);
    if (iVar2 == 0x18) {
        _data.01f6b480 = strtok(data.01f6b400, data.0000410d);
        for (var_ch._0_4_ = 1; (int32_t)var_ch < 5; var_ch._0_4_ = (int32_t)var_ch + 1) {
            uVar3 = strtok(0, data.0000410d);
            *(undefined8 *)(data.01f6b480 + (int64_t)(int32_t)var_ch * 8) = uVar3;
            if (*(int64_t *)(data.01f6b480 + (int64_t)(int32_t)var_ch * 8) == 0) {
                return 0;
            }
        }
        iVar1 = check_md5_hash();
        if ((((iVar1 != 0) && (iVar1 = check_year(), iVar1 != 0)) && (iVar1 = check_xor_pattern(), iVar1 != 0)) &&
           ((iVar1 = check_digit_sum(), iVar1 != 0 && (iVar1 = check_final_part(), iVar1 != 0)))) {
            return 1;
        }
    }
    return 0;
}

// MD5 HASH CHECK - Validates the first part against expected MD5 hash
bool check_md5_hash(void)
{
    int32_t iVar1;
    int64_t in_FS_OFFSET;
    int64_t var_5ch;
    int64_t var_50h;
    void *s2;
    int64_t var_40h;
    int64_t var_38h;
    int64_t var_30h;
    int64_t var_28h;
    int64_t var_20h;
    int64_t canary;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    var_38h = 0x6a7064ccc266ccc8;
    var_30h = 0x6c646466c864cacc;
    var_28h = 0x606a6c626c66c6c6;
    var_20h = 0x6a64686acac27268;
    for (var_5ch._0_4_ = 0; (int32_t)var_5ch < 0x20; var_5ch._0_4_ = (int32_t)var_5ch + 1) {
        *(uint8_t *)((int64_t)&var_38h + (int64_t)(int32_t)var_5ch) =
             *(uint8_t *)((int64_t)&var_38h + (int64_t)(int32_t)var_5ch) >> 1;
    }
    stack0xffffffffffffffa8 = 0;
    var_50h = 0;
    s2 = (void *)0x0;
    var_40h = 0;
    compute_md5_hash((int64_t)&var_5ch + 4);
    hex_string_to_bytes((char *)&var_38h, (int64_t)&s2);
    iVar1 = memcmp((int64_t)&var_5ch + 4, &s2, 0x10);
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return iVar1 == 0;
}

// YEAR CHECK - Validates that the second part matches current year
bool check_year(void)
{
    int32_t iVar1;
    int32_t iVar2;
    int64_t in_FS_OFFSET;
    time_t timer;
    tm *var_28h;
    int64_t canary;
    int64_t var_10h;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    timer = time(0);
    var_28h = (tm *)localtime(&timer);
    var_28h->tm_year = var_28h->tm_year + 0x76c;
    iVar1 = var_28h->tm_year;
    iVar2 = atoi(_data.01f6b488);
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return iVar1 == iVar2;
}

// XOR PATTERN CHECK - Validates the third part against XOR pattern
undefined8 check_xor_pattern(void)
{
    int64_t var_ch;
    
    var_ch._0_4_ = 0;
    while( true ) {
        if (3 < (int32_t)var_ch) {
            return 1;
        }
        if ((*(uint8_t *)((int32_t)var_ch + _data.01f6b490) ^ 0x18) != *(uint8_t *)((int32_t)var_ch + _data.01f6b3c0))
        break;
        var_ch._0_4_ = (int32_t)var_ch + 1;
    }
    return 0;
}

// DIGIT SUM CHECK - Validates that sum of digits is divisible by 7
bool check_digit_sum(void)
{
    int64_t in_FS_OFFSET;
    int var_28h;
    int64_t var_24h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int64_t canary;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    var_28h = atoi(_data.01f6b498);
    var_24h._0_4_ = extract_digit_and_advance((int)&var_28h);
    var_24h._4_4_ = extract_digit_and_advance((int)&var_28h);
    var_1ch = extract_digit_and_advance((int)&var_28h);
    var_18h = extract_digit_and_advance((int)&var_28h);
    var_14h = var_18h + (int32_t)var_24h + var_24h._4_4_ + var_1ch;
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return var_14h % 7 == 0;
}

// FINAL PART CHECK - Validates that the last part is "6666"
undefined8 check_final_part(void)
{
    undefined8 uVar1;
    int64_t var_ch;
    
    if ((*_data.01f6b4a0 < '0') && ('9' < *_data.01f6b4a0)) {
        uVar1 = 0;
    } else if ((*_data.01f6b4a0 == _data.01f6b4a0[1]) &&
              (((_data.01f6b4a0[1] == _data.01f6b4a0[2] && (_data.01f6b4a0[2] == _data.01f6b4a0[3])) &&
               (*_data.01f6b4a0 == '6')))) {
        uVar1 = 1;
    } else {
        uVar1 = 0;
    }
    return uVar1;
}

// ====================================================================
// GAME EXTRACTION FUNCTION
// ====================================================================

// GAME EXTRACTION - Extracts the game file using XOR decryption
void extract_game_file(void)
{
    int32_t iVar1;
    undefined8 uVar2;
    int64_t iVar3;
    int64_t in_FS_OFFSET;
    int c;
    int32_t nbytes;
    char *s1;
    char *ptr;
    
    unique0x0000c280 = *(int64_t *)(in_FS_OFFSET + 0x28);
    uVar2 = strcat(_data.01f6b480, _data.01f6b490);
    iVar3 = strcat(uVar2, _data.01f6b4a0);
    iVar1 = open("pengu-game.appimage", 0x242, 0x1b6);
    if (iVar1 == -1) {
        perror("open");
    } else {
        puts(data.00004128);
        printf("\n\n\t\t");
        printf("\x1b[0;91mExtracting...\n\n\x1b[0m");
        putchar(9);
        for (stack0xffffffffffffffd0 = 0; stack0xffffffffffffffd0 < 0x1a; unique0x00005780 = stack0xffffffffffffffd0 + 1
            ) {
            putchar(0x2e);
        }
        putchar(0xd);
        putchar(9);
        fflush(_stdout);
        for (nbytes = 0; nbytes < 0x7d94c0; nbytes = nbytes + 1) {
            ptr._0_1_ = (uint8_t)*(undefined4 *)(data.000060c0 + (int64_t)nbytes * 4) ^
                        *(uint8_t *)(iVar3 + nbytes % 0xd);
            write(iVar1, &ptr, 1);
            if (nbytes % 0x4d47d == 0) {
                putchar(0x23);
                fflush(_stdout);
            }
        }
        puts("\x1b[0m\n\n");
        puts("Your game has been extracted successfully!");
        puts("shasum of the game : d77b168b2c963605579203bd3bbcdd6320122eb7");
    }
    if (stack0xfffffffffffffff0 != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return;
}

// ====================================================================
// MD5 HASH COMPUTATION FUNCTIONS
// ====================================================================

// COMPUTE MD5 HASH - Computes MD5 hash of the first serial key part
void compute_md5_hash(int64_t arg1)
{
    int64_t arg3;
    int64_t in_FS_OFFSET;
    int64_t var_30h;
    int64_t var_28h;
    int64_t canary;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    md5_init(&var_28h);
    arg3 = strlen(_data.01f6b480);
    md5_update((int64_t)&var_28h, _data.01f6b480, arg3);
    md5_final((int64_t)&var_28h, arg1);
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return;
}

// MD5 INITIALIZATION - Initializes MD5 context
void md5_init(void *arg1)
{
    void *s;
    
    if (arg1 == (void *)0x0) {
    // WARNING: Subroutine does not return
        __assert_fail("ctx != NULL", "md5.c", 0x78, "md5_init");
    }
    memset(arg1, 0, 0x10);
    *(undefined4 *)arg1 = 0x67452301;
    *(undefined4 *)((int64_t)arg1 + 4) = 0xefcdab89;
    *(undefined4 *)((int64_t)arg1 + 8) = 0x98badcfe;
    *(undefined4 *)((int64_t)arg1 + 0xc) = 0x10325476;
    return;
}

// MD5 UPDATE - Updates MD5 context with input data
void md5_update(int64_t arg1, int64_t arg2, int64_t arg3)
{
    int64_t iVar1;
    int64_t in_FS_OFFSET;
    int64_t var_90h;
    int64_t var_88h;
    int64_t var_80h;
    void *s2;
    size_t n;
    int64_t var_60h;
    void *s1;
    int64_t var_20h;
    int64_t canary;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    iVar1 = arg3 << 3;
    s2 = (void *)arg2;
    for (n = arg3; 0x40 < (int64_t)n; n = n - 0x40) {
        md5_block(arg1, s2);
        s2 = (void *)((int64_t)s2 + 0x40);
    }
    memset(&s1, 0, 0x40);
    memcpy(&s1, s2, n);
    if (n == 0x40) {
        md5_block(arg1, &s1);
        memset(&s1, 0, 0x40);
        s1._0_1_ = 0x80;
    } else {
        *(undefined *)((int64_t)&s1 + n) = 0x80;
        if ((int64_t)(0x3f - n) < 8) {
            md5_block(arg1, &s1);
            memset(&s1, 0, 0x40);
        }
    }
    var_20h._0_1_ = (undefined)iVar1;
    var_20h._1_1_ = (undefined)((uint64_t)iVar1 >> 8);
    var_20h._2_1_ = (undefined)((uint64_t)iVar1 >> 0x10);
    var_20h._3_1_ = (undefined)((uint64_t)iVar1 >> 0x18);
    var_20h._4_1_ = (undefined)((uint64_t)iVar1 >> 0x20);
    var_20h._5_1_ = (undefined)((uint64_t)iVar1 >> 0x28);
    var_20h._6_1_ = (undefined)((uint64_t)iVar1 >> 0x30);
    var_20h._7_1_ = (undefined)((uint64_t)iVar1 >> 0x38);
    md5_block(arg1, &s1);
    memset(&s1, 0, 0x40);
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return;
}

// MD5 BLOCK PROCESSING - Processes a 64-byte block for MD5
void md5_block(unsigned long long arg1, void *arg2)
{
    int32_t iVar1;
    uint32_t uVar2;
    uint32_t uVar3;
    uint32_t uVar4;
    uint32_t uVar5;
    int64_t in_FS_OFFSET;
    void *var_78h;
    unsigned long long n;
    int64_t var_68h;
    void *s;
    int64_t var_50h;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int64_t canary;
    
    canary = *(int64_t *)(in_FS_OFFSET + 0x28);
    if (arg1 == 0) {
    // WARNING: Subroutine does not return
        __assert_fail("ctx != NULL", "md5.c", 0x20, "md5_block");
    }
    // WARNING: Load size is inaccurate
    s._0_4_ = *arg2;
    s._4_4_ = *(int32_t *)((int64_t)arg2 + 4);
    var_50h._0_4_ = *(int32_t *)((int64_t)arg2 + 8);
    var_50h._4_4_ = *(int32_t *)((int64_t)arg2 + 0xc);
    var_48h = *(int32_t *)((int64_t)arg2 + 0x10);
    var_44h = *(int32_t *)((int64_t)arg2 + 0x14);
    var_40h = *(int32_t *)((int64_t)arg2 + 0x18);
    var_3ch = *(int32_t *)((int64_t)arg2 + 0x1c);
    var_38h = *(int32_t *)((int64_t)arg2 + 0x20);
    var_34h = *(int32_t *)((int64_t)arg2 + 0x24);
    var_30h = *(int32_t *)((int64_t)arg2 + 0x28);
    var_2ch = *(int32_t *)((int64_t)arg2 + 0x2c);
    var_28h = *(int32_t *)((int64_t)arg2 + 0x30);
    var_24h = *(int32_t *)((int64_t)arg2 + 0x34);
    var_20h = *(int32_t *)((int64_t)arg2 + 0x38);
    var_1ch = *(int32_t *)((int64_t)arg2 + 0x3c);
    uVar5 = *(uint32_t *)(arg1 + 4);
    uVar4 = *(uint32_t *)(arg1 + 8);
    uVar3 = *(uint32_t *)(arg1 + 0xc);
    // [MD5 algorithm implementation - 64 rounds of operations]
    // ... (keeping the full MD5 implementation as is, it's too long to show here)
    *(uint32_t *)arg1 = *(int32_t *)arg1 + uVar2;
    *(uint32_t *)(arg1 + 4) = *(int32_t *)(arg1 + 4) + iVar1 + uVar4;
    *(uint32_t *)(arg1 + 8) = *(int32_t *)(arg1 + 8) + uVar4;
    *(uint32_t *)(arg1 + 0xc) = *(int32_t *)(arg1 + 0xc) + uVar3;
    memset(&s, 0, 0x40);
    if (canary != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        __stack_chk_fail();
    }
    return;
}

// MD5 FINAL - Finalizes MD5 hash computation and extracts result
void md5_final(int64_t arg1, int64_t arg2)
{
    int64_t var_18h;
    int64_t var_10h;
    
    *(char *)arg2 = (char)*(undefined4 *)arg1;
    *(char *)(arg2 + 1) = (char)((uint32_t)*(undefined4 *)arg1 >> 8);
    *(char *)(arg2 + 2) = (char)((uint32_t)*(undefined4 *)arg1 >> 0x10);
    *(char *)(arg2 + 3) = (char)((uint32_t)*(undefined4 *)arg1 >> 0x18);
    *(char *)(arg2 + 4) = (char)*(undefined4 *)(arg1 + 4);
    *(char *)(arg2 + 5) = (char)((uint32_t)*(undefined4 *)(arg1 + 4) >> 8);
    *(char *)(arg2 + 6) = (char)((uint32_t)*(undefined4 *)(arg1 + 4) >> 0x10);
    *(char *)(arg2 + 7) = (char)((uint32_t)*(undefined4 *)(arg1 + 4) >> 0x18);
    *(char *)(arg2 + 8) = (char)*(undefined4 *)(arg1 + 8);
    *(char *)(arg2 + 9) = (char)((uint32_t)*(undefined4 *)(arg1 + 8) >> 8);
    *(char *)(arg2 + 10) = (char)((uint32_t)*(undefined4 *)(arg1 + 8) >> 0x10);
    *(char *)(arg2 + 0xb) = (char)((uint32_t)*(undefined4 *)(arg1 + 8) >> 0x18);
    *(char *)(arg2 + 0xc) = (char)*(undefined4 *)(arg1 + 0xc);
    *(char *)(arg2 + 0xd) = (char)((uint32_t)*(undefined4 *)(arg1 + 0xc) >> 8);
    *(char *)(arg2 + 0xe) = (char)((uint32_t)*(undefined4 *)(arg1 + 0xc) >> 0x10);
    *(char *)(arg2 + 0xf) = (char)((uint32_t)*(undefined4 *)(arg1 + 0xc) >> 0x18);
    return;
}

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================

// HEX STRING TO BYTES - Converts a 32-character hex string to 16 bytes
void hex_string_to_bytes(char *arg1, int64_t arg2)
{
    char cVar1;
    char cVar2;
    int64_t iVar3;
    int64_t var_38h;
    char *s;
    int64_t var_20h;
    int64_t var_10h;
    
    iVar3 = strlen(arg1);
    if (iVar3 != 0x20) {
    // WARNING: Subroutine does not return
        __assert_fail("strlen(hex) == 32", "tools.c", 0x12, "hex_string_to_bytes");
    }
    var_20h._0_4_ = 0;
    for (var_20h._4_4_ = 0; var_20h._4_4_ < 0x20; var_20h._4_4_ = var_20h._4_4_ + 2) {
        cVar1 = hex_digit_to_int((uint64_t)(uint32_t)(int32_t)arg1[var_20h._4_4_]);
        cVar2 = hex_digit_to_int((uint64_t)(uint32_t)(int32_t)arg1[(int64_t)var_20h._4_4_ + 1]);
        *(char *)(arg2 + (int32_t)var_20h) = cVar1 * '\x10' + cVar2;
        var_20h._0_4_ = (int32_t)var_20h + 1;
    }
    return;
}

// HEX DIGIT TO INT - Converts a single hex character to integer
int32_t hex_digit_to_int(int64_t arg1)
{
    char cVar1;
    int32_t iVar2;
    int64_t var_ch;
    
    cVar1 = (char)arg1;
    iVar2 = (int32_t)cVar1;
    if (0x66 < iVar2) goto code_r0x000012a5;
    if (iVar2 < 0x61) {
        if (iVar2 < 0x3a) {
            if (iVar2 < 0x30) {
code_r0x000012a5:
    // WARNING: Subroutine does not return
                __assert_fail("0 && \"invalid hex character\"", "tools.c", 0xc, "hex_digit_to_int");
            }
            iVar2 = cVar1 + -0x30;
        } else {
            if (5 < iVar2 - 0x41U) goto code_r0x000012a5;
            iVar2 = cVar1 + -0x37;
        }
    } else {
        iVar2 = cVar1 + -0x57;
    }
    return iVar2;
}

// EXTRACT DIGIT AND ADVANCE - Extracts last digit and divides number by 10
int32_t extract_digit_and_advance(int arg1)
{
    int32_t iVar1;
    int32_t *piVar2;
    undefined4 in_RDI;
    int var_20h;
    int64_t var_ch;
    
    piVar2 = (int32_t *)CONCAT44(in_RDI, arg1);
    iVar1 = *piVar2;
    *piVar2 = *piVar2 / 10;
    return iVar1 % 10;
}

// LEFT ROTATE - Rotates bits left (used in MD5)
uint32_t left_rotate(int64_t arg1, int64_t arg2)
{
    uint8_t uVar1;
    int64_t var_ch;
    
    uVar1 = (uint8_t)arg2 & 0x1f;
    return (uint32_t)arg1 << uVar1 | (uint32_t)arg1 >> 0x20 - uVar1;
}

// PRINT HEX - Prints 16 bytes as hexadecimal
void print_hex(int64_t arg1)
{
    int64_t var_20h;
    int64_t var_ch;
    
    for (var_ch._0_4_ = 0; (int32_t)var_ch < 0x10; var_ch._0_4_ = (int32_t)var_ch + 1) {
        printf("%02X", *(undefined *)(arg1 + (int32_t)var_ch));
    }
    putchar(10);
    return;
}

// EMPTY FUNCTION - Placeholder function
void empty_function(void)
{
    return;
}

// ENTRY POINT - Program entry with libc setup
void entry0(undefined8 placeholder_0, undefined8 placeholder_1, int64_t arg3)
{
    undefined8 unaff_retaddr;
    undefined auStack_8 [8];
    
    (*___libc_start_main)(main, unaff_retaddr, &stack0x00000008, 0, 0, arg3, auStack_8);
    do {
    // WARNING: Do nothing block with infinite loop
    } while( true );
}
